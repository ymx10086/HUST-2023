fun printBool (a:bool) =      print(Bool.toString(a)^" ");    fun printInt (a:int) =     print(Int.toString(a)^" ");  fun getInt () =     Option.valOf (TextIO.scanStream (Int.scan StringCvt.DEC) TextIO.stdIn);      fun printIntList ( [] ) = ()   | printIntList ( x::xs ) =      let 	val tmp = printInt(x)     in 	printIntList(xs)     end;  fun getIntList ( 0 ) = []   | getIntList ( N:int) = getInt()::getIntList(N-1);  fun split [ ]  = ([ ], [ ])      | split [x] = ([ ], [x])     | split (x::y::L) = 	let val (A, B) =split L 	in (x::A, y::B) 	 	end;  datatype tree = Empty | Br of tree * int * tree;   fun trav(Br(t1,a,t2)) = trav(t1)@(a::trav(t2))     |trav empty = [];  (*BEGIN*) fun listToTree ([] : int list) : tree = Empty   | listToTree (x::l) =    let val (leftList, rightList) = split l  (* 使用 split 函数将列表分割成左右两部分 *)        in Br (listToTree leftList, x, listToTree rightList)  (* 递归构建平衡树 *)        end; fun binarySearch (Empty : tree, _ : int) : bool = false  (* 空树中不包含任何节点 *)   | binarySearch (Br (left, value, right), target) =             case Int.compare(value, target) of EQUAL => true  (* 找到目标值，返回true *)             | GREATER => binarySearch (left, target)  (* 目标值小于当前节点的值，向左子树搜索 *)             | LESS => binarySearch (right, target);  (* 目标值大于当前节点的值，向右子树搜索 *) (*END*)  val L = getIntList(7); val h= getInt(); printBool(binarySearch((listToTree L), h));